"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sign = void 0;
var xrpl_sign_keypairs_1 = __importDefault(require("xrpl-sign-keypairs"));
var Account_1 = __importDefault(require("../schema/Account"));
var sign = function (transaction, account) {
    var accounts = [];
    var Tx = Object.assign({}, transaction);
    if (Object.keys(Tx).indexOf('TransactionType') > -1) {
        if (Tx['TransactionType'].toLowerCase() === 'signin') {
            Object.assign(Tx, {
                TransactionType: undefined,
                SignIn: true
            });
        }
    }
    if (account instanceof Object && !Array.isArray(account)) {
        if (account instanceof Account_1.default) {
            accounts.push(account);
        }
        else {
            throw new Error("Account not instanceof XRPL Account");
        }
    }
    else if (Array.isArray(account)) {
        account.forEach(function (account) {
            if (account instanceof Account_1.default) {
                accounts.push(account);
            }
            else {
                throw new Error("Account not instanceof XRPL Account");
            }
        });
    }
    if (accounts.length === 1) {
        var txJSON = JSON.stringify(Tx);
        var signAs = {};
        if (typeof accounts[0]._signAs === "string" && accounts[0]._signAs !== "") {
            // signAs explicitly set
            signAs = { signAs: accounts[0]._signAs };
        }
        var tx = xrpl_sign_keypairs_1.default(txJSON, accounts[0].keypair, signAs);
        return {
            type: "SignedTx",
            id: tx.id,
            signedTransaction: tx.signedTransaction,
            txJson: tx.txJson,
            signers: [
                // @ts-ignore
                typeof accounts[0]._signAs === "string"
                    ? accounts[0]._signAs
                    : accounts[0].address
            ]
        };
    }
    else {
        var RippleLibApi = require("ripple-lib").RippleAPI;
        var RippleApi_1 = new RippleLibApi();
        var Codec = require("ripple-binary-codec");
        var MultiSignedTransactionBinary = (function () {
            if (transaction instanceof Object &&
                Array.isArray(transaction) &&
                accounts.length === 0 &&
                transaction.length > 0) {
                if (transaction.length ===
                    transaction.filter(function (t) {
                        return (t instanceof Object &&
                            t !== null &&
                            typeof t.signedTransaction === "string");
                    }).length) {
                    // MultiSign [ { signedTransaction: ... } , ... ]
                    return RippleApi_1.combine(transaction.map(function (t) {
                        return t.signedTransaction.toUpperCase();
                    }));
                }
                else if (transaction.length ===
                    transaction.filter(function (t) {
                        return (typeof t === "string" && t.toUpperCase().match(/^[A-F0-9]+$/));
                    }).length) {
                    // MultiSign [ 'AEF9...', 'C6DA...' ]
                    return RippleApi_1.combine(transaction.map(function (t) {
                        return t.toUpperCase();
                    }));
                }
                else {
                    throw new Error("TX Blob for multiSign not an array of { signedTransaction: ... } objects or blob strings");
                }
            }
            else {
                // MultiSign [ lib.sign(...), lib.sign(...) ]
                return RippleApi_1.combine(accounts.map(function (account) {
                    return xrpl_sign_keypairs_1.default(JSON.stringify(Tx), account.keypair, {
                        signAs: typeof account._signAs === "string"
                            ? account._signAs
                            : account.address
                    }).signedTransaction;
                }));
            }
        })();
        var txJson = Codec.decode(MultiSignedTransactionBinary.signedTransaction);
        return {
            type: "MultiSignedTx",
            id: MultiSignedTransactionBinary.id,
            signedTransaction: MultiSignedTransactionBinary.signedTransaction,
            txJson: txJson,
            signers: txJson.Signers
        };
    }
};
exports.sign = sign;
exports.default = sign;
