"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.completeMultiSigned = exports.complete = exports.prepare = exports.accountAddress = void 0;
var Utils = __importStar(require("../utils"));
var ripple_hashes_1 = require("ripple-hashes");
var assert_1 = __importDefault(require("assert"));
var ripple_lib_1 = require("ripple-lib");
var ripple_binary_codec_1 = require("ripple-binary-codec");
var assertValidPubkey = function (pubkey) {
    assert_1.default(typeof pubkey === "string", "Uncompressed PubKey: string expected");
    if (pubkey.length === 64) {
        // ED Uncompressed
        assert_1.default(Utils.getAlgorithmFromKey("ED" + pubkey) === "ed25519", "Key length ed25519, algo not ed25519");
    }
    else if (pubkey.length === 66) {
        // Compressed (?)
        assert_1.default(Utils.deriveAddress("A" + pubkey.slice(1)), "Compressed PubKey length, invalid address derivation");
    }
    else {
        // Secp256k1 Uncompressed
        assert_1.default(pubkey.length === 130, "Uncompressed PubKey: incorrect length");
        assert_1.default(pubkey.slice(0, 2) === "04", 'Uncompressed PubKey: should start with "04"');
    }
};
/**
 * Prepare a transaction for a Raw card: get Hash to sign
 */
var prepare = function (txJson, pubkey, multiSign) {
    if (multiSign === void 0) { multiSign = false; }
    assertValidPubkey(pubkey);
    var signingPubKey = Utils.compressPubKey(pubkey);
    var transaction = Object.assign({}, __assign({}, txJson));
    assert_1.default(typeof transaction === "object" && transaction !== null, "Transaction: Object expected");
    if (typeof transaction.signingPubKey === "undefined") {
        Object.assign(transaction, { SigningPubKey: signingPubKey });
    }
    if (multiSign) {
        Object.assign(transaction, { SigningPubKey: "" });
    }
    var message = Utils.encodeTransaction(transaction, multiSign ? Utils.deriveAddress(signingPubKey) : undefined);
    var hashToSign = Utils.getAlgorithmFromKey(signingPubKey) === "ed25519"
        ? message
        : Utils.bytesToHex(Utils.hash(message));
    return {
        pubkey: pubkey,
        signingPubKey: signingPubKey,
        multiSign: multiSign,
        transaction: transaction,
        message: message,
        hashToSign: hashToSign,
    };
};
exports.prepare = prepare;
var complete = function (Prepared, signature) {
    assertValidPubkey(Prepared.pubkey);
    assert_1.default(typeof signature === "string", "signature: string expected");
    assert_1.default(signature.length === 128, "signature: incorrect length");
    var txnSignature = Utils.getAlgorithmFromKey(Prepared.signingPubKey) === "ed25519"
        ? signature
        : Utils.secp256k1_p1363ToFullyCanonicalDerSignature(signature);
    var signatureVerifies = Utils.verifySignature(Prepared.message, txnSignature, Prepared.signingPubKey);
    var txJson = {};
    var signedTransaction = "";
    var id = "";
    Object.assign(txJson, Prepared.transaction);
    if (signatureVerifies) {
        Object.assign(txJson, { TxnSignature: txnSignature });
        signedTransaction = Utils.encodeTransaction(txJson);
        id = ripple_hashes_1.computeBinaryTransactionHash(signedTransaction);
    }
    return {
        type: "SignedTx",
        txnSignature: txnSignature,
        signatureVerifies: signatureVerifies,
        txJson: txJson,
        signedTransaction: signedTransaction,
        id: id,
    };
};
exports.complete = complete;
var completeMultiSigned = function (txJson, SignersAndSignatures) {
    assert_1.default(Array.isArray(SignersAndSignatures), "SignersAndSignatures not array");
    assert_1.default(SignersAndSignatures.length > 0, "SignersAndSignatures empty");
    var transaction = Object.assign({}, txJson);
    Object.assign(transaction, { SigningPubKey: "" });
    // const hashToSign = Utils.bytesToHex(Utils.hash(message))
    var toCombine = SignersAndSignatures.map(function (SignerAndSignature) {
        var pubKey = SignerAndSignature.pubKey.length === 130
            ? Utils.compressPubKey(SignerAndSignature.pubKey)
            : SignerAndSignature.pubKey.length === 64
                ? "ED" + SignerAndSignature.pubKey
                : SignerAndSignature.pubKey;
        var signerAddress = Utils.deriveAddress(pubKey);
        var txnSignature = Utils.getAlgorithmFromKey(pubKey) === "ed25519"
            ? SignerAndSignature.signature
            : Utils.secp256k1_p1363ToFullyCanonicalDerSignature(SignerAndSignature.signature);
        var message = Utils.encodeTransaction(transaction, signerAddress);
        // console.log({message, txnSignature, pubKey})
        var signatureVerifies = Utils.verifySignature(message, txnSignature, pubKey);
        assert_1.default(signatureVerifies, "Invalid signature by/for " + signerAddress);
        Object.assign(transaction, {
            Signers: [
                {
                    Signer: {
                        Account: signerAddress,
                        SigningPubKey: pubKey,
                        TxnSignature: txnSignature,
                    },
                },
            ],
        });
        var MultiSignature = {
            signerAddress: signerAddress,
            signature: SignerAndSignature.signature,
            verifies: signatureVerifies,
            transaction: transaction,
            signedTransaction: Utils.encodeTransaction(transaction),
        };
        return MultiSignature;
    });
    // console.dir(toCombine, {depth: null})
    var combined = new ripple_lib_1.RippleAPI().combine(toCombine.map(function (c) { return c.signedTransaction; }));
    var signedTransaction = String(combined.signedTransaction || "");
    return {
        type: "MultiSignedTx",
        txnSignature: "",
        signatureVerifies: toCombine.every(function (s) { return s.verifies; }),
        txJson: ripple_binary_codec_1.decode(signedTransaction),
        signedTransaction: signedTransaction,
        id: String(combined.id || ""),
    };
};
exports.completeMultiSigned = completeMultiSigned;
var accountAddress = function (pubkey) {
    assertValidPubkey(pubkey);
    var signingPubKey = Utils.compressPubKey(pubkey);
    return Utils.deriveAddress(signingPubKey);
};
exports.accountAddress = accountAddress;
